#include "ProtoVM.h"
#include "CadcSystem.h"

/*
 * F-14 CADC System Implementation
 * Implements the complete CADC system with interconnection and timing
 */

CadcSystem::CadcSystem() {
    // Initialize system components
    mul_module = new ICcadcModule();  // Multiply module with PMU
    div_module = new ICcadcModule();  // Divide module with PDU  
    slf_module = new ICcadcModule();  // Special Logic module with SLF
    // For now, we'll make sys_exec_ctrl a separate component or remove it 
    // since ICcadcBase is abstract. For a real implementation we'd need a concrete class
    
    // Initialize timing variables
    system_cycle = 0;
    bit_time = 0;
    word_time = 0;
    operation_time = 0;
    frame_mark = false;
    word_mark = false;
    is_running = false;
    is_busy = false;
    
    // Add system pins
    AddSink("PRESSURE_IN");
    AddSink("TEMP_IN");
    AddSink("ANGLE_OF_ATTACK");
    AddSink("START");
    AddSink("RESET");
    AddSource("BUSY");
    AddSource("VALID_OUTPUT");
    AddSource("ALTITUDE_OUT");
    AddSource("VERTICAL_SPEED_OUT");
    AddSource("AIR_SPEED_OUT");
    AddSource("MACH_NUMBER_OUT");
    AddSink("SYS_CLK");
    
    LOG("CadcSystem: Initialized with 3 pipeline modules");
}

CadcSystem::~CadcSystem() {
    // Clean up components
    delete mul_module;
    delete div_module;
    delete slf_module;
    // sys_exec_ctrl is not used since it would require a concrete implementation of ICcadcBase
}

bool CadcSystem::Tick() {
    // Update system timing
    UpdateSystemTiming();
    
    // Update all modules
    mul_module->Tick();
    div_module->Tick();
    slf_module->Tick();
    // sys_exec_ctrl tick is not called since it's not implemented as a concrete class
    
    // Handle module communication and data exchange
    HandleModuleCommunication();
    
    // Execute air data computations
    ExecuteAirDataComputations();
    
    // Update control signals
    UpdateControlSignals();
    
    return true;
}

bool CadcSystem::Process(ProcessType type, int bytes, int bits, uint16 conn_id, ElectricNodeBase& dest, uint16 dest_conn_id) {
    byte temp_data[3];
    
    if (type == WRITE) {
        // Handle output based on connection ID
        switch (conn_id) {
            case BUSY:
                temp_data[0] = is_busy ? 1 : 0;
                return dest.PutRaw(dest_conn_id, temp_data, 0, 1);
                
            case VALID_OUTPUT:
                temp_data[0] = frame_mark ? 1 : 0;  // Valid when frame mark is set
                return dest.PutRaw(dest_conn_id, temp_data, 0, 1);
                
            case ALTITUDE_OUT:
            case VERTICAL_SPEED_OUT:
            case AIR_SPEED_OUT:
            case MACH_NUMBER_OUT:
                // For this demo, output simple values
                temp_data[0] = 0x42;  // Example value
                temp_data[1] = 0x01;
                temp_data[2] = 0x00;
                return dest.PutRaw(dest_conn_id, temp_data, bytes, bits);
                
            default:
                return true;
        }
    }
    
    return true;
}

bool CadcSystem::PutRaw(uint16 conn_id, byte* data, int data_bytes, int data_bits) {
    switch (conn_id) {
        case START:
            if (data_bits == 1 && *data == 1) {
                is_running = true;
            }
            break;
            
        case RESET:
            if (data_bits == 1 && *data == 1) {
                system_cycle = 0;
                bit_time = 0;
                word_time = 0;
                operation_time = 0;
                is_running = false;
                is_busy = false;
            }
            break;
            
        case PRESSURE_IN:
        case TEMP_IN:
        case ANGLE_OF_ATTACK:
            // Input sensor data - would be processed by the system
            // For now, just store in a buffer for the computations
            break;
            
        case SYS_CLK:
            // System clock input - drives the timing
            break;
            
        default:
            break;
    }
    
    return true;
}

void CadcSystem::UpdateSystemTiming() {
    // Advance timing based on system clock
    // In real CADC: 375 kHz clock = 2.66 Î¼s per bit time
    bit_time = (bit_time + 1) % CADC_WORD_LENGTH;  // 0-19
    
    if (bit_time == 0) {
        // Completed a word time
        word_time = (word_time + 1) % 2;  // Alternates W0 and W1
        system_cycle++;
        
        // Word mark is generated at T18 of every word
        if (bit_time == 18) {
            word_mark = true;
        } else {
            word_mark = false;
        }
    }
    
    // Operation time: Two consecutive word times make one operation time
    if (word_time == 0) {
        operation_time = system_cycle / 2;
    }
    
    // Frame mark: Generated by system executive control at end of computation cycle
    // For this simplified model, set frame mark periodically
    if (system_cycle % 16 == 15) {  // Example: every 16 system cycles
        frame_mark = true;
    } else {
        frame_mark = false;
    }
}

void CadcSystem::HandleModuleCommunication() {
    // Handle data exchange between modules
    // In real CADC, modules communicate through steering units and shared buses
    
    // Example: Route data from RAS in one module to input of another
    // This would involve more complex interconnect logic in a real implementation
    
    // For this simulation, we'll just simulate data exchange between modules
    // based on the operation being performed
    
    // In W0 (instruction fetch), modules receive microcode from their ROMs
    // In W1 (data transfer), modules exchange data and perform operations
    if (word_time == 0) {
        // W0: Instruction fetch phase
        // Modules get their next instruction from ROM
    } else {
        // W1: Data transfer phase
        // Modules process data and possibly exchange with other modules
    }
}

void CadcSystem::ExecuteAirDataComputations() {
    // Execute the core air data computations
    // This simulates the polynomial evaluations, data limiting, etc. that the CADC does
    
    // The CADC computes:
    // - Altitude
    // - Vertical Speed
    // - Air Speed
    // - Mach Number
    // from inputs like:
    // - Static and dynamic pressure
    // - Temperature
    // - Angle of attack
    
    // For this simplified implementation, we'll simulate these calculations:
    
    // Example polynomial evaluation (simplified): F(X) = a3*x^3 + a2*x^2 + a1*x + a0
    // In real CADC, this would be implemented using the PMU and SL modules working together
    
    if (is_running) {
        // Simulate computation progress
        is_busy = true;
        
        // When a computation cycle completes (frame mark), set outputs
        if (frame_mark) {
            is_busy = false;
            
            // Set computed values (simplified)
            // In real implementation, these would come from the actual computations
            // performed by the modules
        }
    }
}

void CadcSystem::UpdateControlSignals() {
    // Update system control signals based on current state
    // The busy status and other signals would be sent through the Process method
    // when other components request them
    
    // Set other control pins as needed
}