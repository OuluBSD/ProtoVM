#include "ProtoVM.h"
#include "Cli.h"
#include "MDS1101SchematicTool.h"
#include "IC4001.h"
#include "IC4002.h"
#include "IC4003.h"
#include "AddressDecoder4004.h"
#include "BusController4004.h"
#include "BusInterface4004.h"
#include "ClockGenerator4004.h"
#include "PowerOnReset4004.h"
#include "Test4004CPU.h"
/*
LinkBases:
	- https://github.com/vygr/C-PCB
*/
void SetupTest0_FlipFlop(Machine& mach);
void SetupTest1_ANDGate(Machine& mach);
void SetupTest2_Counter(Machine& mach);
void SetupTest3_Memory(Machine& mach);
void SetupTest4_6502(Machine& mach);
void SetupTest3_BasicLogicGates(Machine& mach);
void SetupTest4_MuxDemux(Machine& mach);
void SetupTest5_DecoderEncoder(Machine& mach);
void TestBasicLogicGates(Machine& mach);
void Test4BitRegister(Machine& mach);
void Test4BitMemory(Machine& mach);
void Test4BitAdder(Machine& mach);
void SetupUK101(Machine& mach);
void SetupInterak(Machine& mach);
void SetupMiniMax8085(Machine& mach);
void SetupMiniMax4004(Machine& mach);
void RunArithmeticUnitTests(Machine& mach);
void Test60_StateMachine();
void Test70_Basic8BitCPU();
void Test80_ClockDivider();
void Test81_ClockGate();
void Test82_PLL();
void Test90_SignalTracing();
void TestMDS1101SchematicTool();
void Run4004UnitTests();
// Character output function
void OutputCharacter(char c);
// Helper functions for 4004 memory initialization and debugging
bool LoadProgramTo4004ROM(Machine& mach, const String& filename, int start_addr = 0);
void Debug4004CPUState(Machine& mach);
void Poke4004Memory(Machine& mach, int addr, byte value);
byte Peek4004Memory(Machine& mach, int addr);
void Dump4004Memory(Machine& mach, int start_addr, int count);
void TestPslParserFunction();  // Forward declaration
#include "Helper4004.h"
        // Connect RAM control signals (active low CS, active high WE)
        vcc["0"] >> ram["~CS"];  // Chip select active
        ground["0"] >> ram["WE"]; // Write enable inactive (0 = read mode)
        LOG("MiniMax4004 system configured with 4004 CPU, 4001 ROM, 4002 RAM, and bus controller");
    }
    catch (Exc e) {
        LOG("Connection error in SetupMiniMax4004: " << e);
    }
}
// Character output function
void OutputCharacter(char c) {
    // Output the character to the console
    UPP::Cout() << c << UPP::EOL;
    LOG("Character output: '" << c << "' (0x" << HexStr(c) << ")");
}
void TestMDS1101SchematicTool() {
    LOG("Testing MDS-1101 Schematic Tool...");
    // Initialize the schematic tool
    MDS1101SchematicTool tool;
    // Find an appropriate PCB image from the MDS-1101 directory
    // For now, use the first available image as a demonstration
    std::string pcb_image_path = "circuitboards/MDS-1101/machine1.jpg";
    // Load PCB image
    if (!tool.LoadPCBImage(pcb_image_path)) {
        LOG("Failed to load PCB image: " << pcb_image_path);
        return;
    }
    // Analyze the image to detect components and connections
    if (!tool.AnalyzeImage()) {
        LOG("Failed to analyze PCB image");
        return;
    }
    // Generate the schematic from the analysis
    Schematic schematic = tool.GenerateSchematic();
    // Render the schematic for display
    tool.RenderSchematic();
    // Export the schematic to ProtoVM format
    if (!tool.ExportToProtoVM("MDS1101_schematic_output.psl")) {
        LOG("Failed to export schematic to ProtoVM format");
        return;
    }
    LOG("MDS-1101 Schematic Tool test completed successfully");
}

void SetupMiniMax4004(Machine& mach) {
    LOG("MiniMax4004 system configured with 4004 CPU, 4001 ROM, 4002 RAM");
    // Implementation will be added later
}

#ifdef flagMAIN
CONSOLE_APP_MAIN {
	using namespace Upp;
	SetCoutLog();
	// Parse command line arguments
	const Vector<String>& args = CommandLine();
	// Check for help flag
	if (FindIndex(args, "-h") >= 0 || FindIndex(args, "--help") >= 0) {
		Cout() << "ProtoVM Digital Logic Simulator\n";
		Cout() << "Usage: " << GetExeTitle() << " [options] [circuit_name]\n";
		Cout() << "Options:\n";
		Cout() << "  -h, --help     Show this help message\n";
		Cout() << "  -V, --version  Show version information\n";
		Cout() << "  -v              Show verbose output during simulation\n";
		Cout() << "  -vv             Show more verbose output (very verbose)\n";
		Cout() << "  --verbosity=N   Set verbosity level directly (0=minimal, 1=default, 2=verbose, 3=very verbose)\n";
		Cout() << "  -t, --ticks N  Run simulation for N ticks (default: 100)\n";
		Cout() << "  --cli          Start in interactive CLI mode\n";
		Cout() << "  --load-binary <file> [addr]  Load binary program file into memory at specified address\n";
		Cout() << "Circuits:\n";
		Cout() << "  flipflop    - Simple flip-flop test circuit\n";
		Cout() << "  andgate     - Simple AND gate test circuit\n";
		Cout() << "  counter     - 4-bit counter test circuit\n";
		Cout() << "  memory      - Memory test circuit\n";
		Cout() << "  6502        - 6502 CPU test circuit\n";
		Cout() << "  basiclogic  - Basic logic gates test circuit\n";
		Cout() << "  test4bit    - 4-bit register test circuit\n";
		Cout() << "  test4bitmemory - 4-bit memory test circuit\n";
		Cout() << "  muxdemux    - Multiplexer/demultiplexer test circuit\n";
		Cout() << "  decenc      - Decoder/encoder test circuit\n";
		Cout() << "  testgates   - Comprehensive logic gates test\n";
		Cout() << "  uk101       - UK101 computer circuit\n";
		Cout() << "  interak     - Interak computer circuit\n";
		Cout() << "  unittests   - Run unit tests for arithmetic components\n";
		Cout() << "  minimax     - MiniMax 8085 computer circuit\n";
		Cout() << "  statemachine - State machine test circuit\n";
		Cout() << "  basiccpu     - Basic 8-bit CPU test circuit\n";
		Cout() << "  clkdivider   - Clock divider test circuit\n";
		Cout() << "  clkgate      - Clock gating test circuit\n";
		Cout() << "  pll          - Phase-locked loop test circuit\n";
		Cout() << "  signaltrace  - Signal tracing functionality test circuit\n";
		Cout() << "  mds1101      - MDS-1101 schematic tool demonstration\n";
		Cout() << "\nExamples:\n";
		Cout() << "  " << GetExeTitle() << " 6502 -t 1000    # Run 6502 circuit for 1000 ticks\n";
		Cout() << "  " << GetExeTitle() << " --cli           # Start interactive CLI mode\n";
		Cout() << "  " << GetExeTitle() << " testgates       # Run comprehensive logic gate test\n";
		Cout() << "  " << GetExeTitle() << " signaltrace     # Run signal tracing test\n";
		return;
	}
	// Check for version flag (now using -V or --version)
	if (FindIndex(args, "-V") >= 0 || FindIndex(args, "--version") >= 0) {
		Cout() << "ProtoVM Digital Logic Simulator v1.0\n";
		return;
	}
	// Find circuit selection and options
	String circuit_name = ""; // no default - will show help if no circuit provided
	int max_ticks = 100;
	bool interactive_cli = false;
	bool run_psl_test = false;
	int verbosity_level = 0;  // 0=minimal output, 1=default output, 2=verbose output, 3=very verbose
	String binary_file = "";  // Binary file to load
	int load_address = 0; // Address to load the binary file
	for (int i = 0; i < args.GetCount(); i++) {
		String arg = args[i];
		if (arg == "-t" || arg == "--ticks") {
			if (i + 1 < args.GetCount()) {
				max_ticks = StrInt(args[i + 1]);
				i++; // skip next argument
			}
		}
		else if (arg == "--cli") {
			interactive_cli = true;
		}
		else if (arg == "--psl-test") {
			run_psl_test = true;
		}
		else if (arg == "--load-binary" || arg == "-lb") {
			if (i + 1 < args.GetCount()) {
				binary_file = args[i + 1];
				i++; // skip next argument
				// Optionally parse address too
				if (i + 1 < args.GetCount() && !args[i + 1].StartsWith("-")) {
					String addr_str = args[i + 1];
					if (!addr_str.StartsWith("0x") && !addr_str.StartsWith("0X")) {
						addr_str = "0x" + addr_str; // Add 0x prefix for hex parsing
					}
					load_address = StrInt(addr_str);
					i++; // skip next argument
				}
void SetupMiniMax4004(Machine& mach) {
    Pcb& pcb = mach.AddPcb();

    // Create and configure the 4004 CPU
    IC4004& cpu = pcb.Add<IC4004>("CPU4004");

    // Create memory components for the 4004 system
    IC4001& rom = pcb.Add<IC4001>("ROM4001");  // Proper 4001 ROM component
    IC4002& ram = pcb.Add<IC4002>("RAM4002");  // Proper 4002 RAM component

    // Create bus controller for proper bus arbitration
    BusController4004& bus_ctrl = pcb.Add<BusController4004>("BUS_CTRL");

    // Create separate buses for address and other signals
    Bus<12>& addr_bus = pcb.Add<Bus<12>>("ADDR_BUS");

    // Create control pins
    Pin& clk = pcb.Add<Pin>("CLK").SetReference(1);    // Clock HIGH
    Pin& reset = pcb.Add<Pin>("RESET").SetReference(0); // Reset LOW
    Pin& ground = pcb.Add<Pin>("ground").SetReference(0); // Ground
    Pin& vcc = pcb.Add<Pin>("vcc").SetReference(1);     // VCC

    try {
        // Connect CPU data pins to bus controller
        cpu["D0"] >> bus_ctrl["CPU_D0"];
        cpu["D1"] >> bus_ctrl["CPU_D1"];
        cpu["D2"] >> bus_ctrl["CPU_D2"];
        cpu["D3"] >> bus_ctrl["CPU_D3"];
        
        // Connect ROM data pins to bus controller
        rom["D0"] >> bus_ctrl["ROM_D0"];
        rom["D1"] >> bus_ctrl["ROM_D1"];
        rom["D2"] >> bus_ctrl["ROM_D2"];
        rom["D3"] >> bus_ctrl["ROM_D3"];
        
        // Connect RAM data pins to bus controller
        bus_ctrl["RAM_DIN0"] >> ram["D0"];
        bus_ctrl["RAM_DIN1"] >> ram["D1"];
        bus_ctrl["RAM_DIN2"] >> ram["D2"];
        bus_ctrl["RAM_DIN3"] >> ram["D3"];
        ram["D0"] >> bus_ctrl["RAM_DOUT0"];
        ram["D1"] >> bus_ctrl["RAM_DOUT1"];
        ram["D2"] >> bus_ctrl["RAM_DOUT2"];
        ram["D3"] >> bus_ctrl["RAM_DOUT3"];

        // Connect address bus
        cpu["A0"] >> addr_bus[0];
        cpu["A1"] >> addr_bus[1];
        cpu["A2"] >> addr_bus[2];
        cpu["A3"] >> addr_bus[3];
        cpu["A4"] >> addr_bus[4];
        cpu["A5"] >> addr_bus[5];
        cpu["A6"] >> addr_bus[6];
        cpu["A7"] >> addr_bus[7];
        cpu["A8"] >> addr_bus[8];
        cpu["A9"] >> addr_bus[9];
        cpu["A10"] >> addr_bus[10];
        cpu["A11"] >> addr_bus[11];

        // Connect ROM address pins directly to address bus
        addr_bus[0] >> rom["A0"];
        addr_bus[1] >> rom["A1"];
        addr_bus[2] >> rom["A2"];
        addr_bus[3] >> rom["A3"];
        addr_bus[4] >> rom["A4"];
        addr_bus[5] >> rom["A5"];
        addr_bus[6] >> rom["A6"];
        addr_bus[7] >> rom["A7"];
        addr_bus[8] >> rom["A8"];
        addr_bus[9] >> rom["A9"];

        // Connect RAM address pins directly to address bus (4-bit address for 4002)
        addr_bus[0] >> ram["A0"];
        addr_bus[1] >> ram["A1"];
        addr_bus[2] >> ram["A2"];
        addr_bus[3] >> ram["A3"];

        // Connect CPU control signals to bus controller and components
        clk >> cpu["CM4"];        // Clock to CPU
        reset >> cpu["RES"];      // Reset to CPU

        // Connect CPU control signals that were unconnected before
        cpu["CM"] >> ground["0"];   // CPU clock output to ground
        cpu["BUSY"] >> ground["0"]; // Busy signal to ground
        cpu["R/W"] >> bus_ctrl["CPU_R/W"]; // Connect to bus controller
        cpu["MR"] >> bus_ctrl["CPU_MR"];   // Connect to bus controller
        cpu["MW"] >> bus_ctrl["CPU_MW"];   // Connect to bus controller
        cpu["SBY"] >> ground["0"];  // System busy to ground

        // Connect bus controller clock signals
        clk >> bus_ctrl["CPU_CLK"];
        clk >> bus_ctrl["MEM_CLK"];  // For simplicity, using same clock

        // Connect ROM control signals (active low)
        vcc["0"] >> rom["~OE"];  // Output enable active
        vcc["0"] >> rom["~CS"];  // Chip select active

        // Connect RAM control signals (active low CS, active high WE)
        vcc["0"] >> ram["~CS"];  // Chip select active
        ground["0"] >> ram["WE"]; // Write enable inactive (0 = read mode)

        LOG("MiniMax4004 system configured with 4004 CPU, 4001 ROM, 4002 RAM, and bus controller");
    }
    catch (Exc e) {
        LOG("Connection error in SetupMiniMax4004: " << e);
    }
}
}
