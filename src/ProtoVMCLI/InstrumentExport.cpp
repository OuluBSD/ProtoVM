#include "InstrumentExport.h"

#include <sstream>
#include <iomanip>

namespace ProtoVM {

    Result<std::string> InstrumentExport::EmitStandaloneCppForInstrument(
        const InstrumentGraph& instrument,
        const InstrumentExportOptions& options
    ) {
        std::ostringstream source;
        
        if (options.emit_comment_banner) {
            source << "// Generated by ProtoVM InstrumentExport\n";
            source << "// Instrument ID: " << instrument.instrument_id << "\n";
            source << "// Exported on: " << /* TODO: add timestamp */ "TIMESTAMP" << "\n\n";
        }

        // Include necessary headers
        source << "#include <cmath>\n";
        source << "#include <cstdint>\n";
        source << "#include <vector>\n";
        source << "#include <fstream>\n";
        source << "#include <iostream>\n";
        source << "#include <algorithm>\n\n";

        // Define namespace if provided
        if (!options.namespace_name.empty()) {
            source << "namespace " << options.namespace_name << " {\n\n";
        }

        // Define constants for the instrument
        source << "// Instrument Configuration\n";
        source << "const int SAMPLE_RATE = " << static_cast<int>(instrument.sample_rate_hz) << ";\n";
        source << "const double DURATION_SEC = " << std::fixed << std::setprecision(2) << instrument.note.duration_sec << ";\n";
        source << "const int TOTAL_SAMPLES = static_cast<int>(SAMPLE_RATE * DURATION_SEC);\n";
        source << "const int VOICE_COUNT = " << instrument.voice_count << ";\n";
        source << "const double BASE_FREQ = " << std::fixed << std::setprecision(2) << instrument.note.base_freq_hz << ";\n";
        source << "const double PAN_LFO_HZ = " << std::fixed << std::setprecision(2) << instrument.voice_template.pan_lfo_hz << ";\n\n";

        // Struct for voice state
        source << "// Voice state structure\n";
        source << "struct VoiceState {\n";
        source << "    double phase;\n";
        source << "    double freq;\n";
        source << "    double detune_factor;\n";
        source << "    \n";
        source << "    VoiceState(double base_freq, double detune_cents) : \n";
        source << "        phase(0.0),\n";
        source << "        detune_factor(std::pow(2.0, detune_cents / 1200.0)),\n";
        source << "        freq(base_freq * detune_factor) {}\n";
        source << "};\n\n";

        // Function to generate a sample for a voice
        source << "// Generate a sample for a voice\n";
        source << "float GenerateVoiceSample(VoiceState& voice) {  // Note: voice is passed by reference to allow modification\n";
        source << "    // Simple sine wave oscillator (approximation of analog oscillator behavior)\n";
        source << "    float sample = static_cast<float>(std::sin(voice.phase));\n";
        source << "    \n";
        source << "    // Advance phase for next sample\n";
        source << "    voice.phase += 2.0 * M_PI * voice.freq / SAMPLE_RATE;\n";
        source << "    \n";
        source << "    // Keep phase in [0, 2*PI] range to prevent drift\n";
        source << "    while (voice.phase >= 2.0 * M_PI) {\n";
        source << "        voice.phase -= 2.0 * M_PI;\n";
        source << "    }\n";
        source << "    \n";
        source << "    return sample;\n";
        source << "}\n\n";

        // Function for pan LFO calculation
        source << "// Calculate pan value using LFO\n";
        source << "float CalculatePan(double time_sec) {\n";
        source << "    double pan_phase = 2.0 * M_PI * PAN_LFO_HZ * time_sec;\n";
        source << "    double pan = 0.5 * (1.0 + std::sin(pan_phase));  // 0..1\n";
        source << "    return static_cast<float>(pan);\n";
        source << "}\n\n";

        // Render function
        source << "// Define M_PI if not available\n";
        source << "#ifndef M_PI\n";
        source << "#define M_PI 3.14159265358979323846\n";
        source << "#endif\n\n";

        source << "// Render function that fills stereo buffers\n";
        source << "void Render(std::vector<float>& left, std::vector<float>& right) {\n";
        source << "    // Initialize all voices with calculated detuning\n";
        source << "    std::vector<VoiceState> voices;\n";

        // For simplicity, we'll generate code assuming a typical detuning pattern
        // In this case, we'll linearly distribute detuning around 0
        if (instrument.voice_count == 1) {
            // If only one voice, use 0 detune
            source << "    voices.emplace_back(BASE_FREQ, 0.0);  // Single voice, no detune\n";
        } else {
            // For multiple voices, create linear distribution
            double detuneSpread = 10.0; // Default spread of 10 cents
            if (instrument.voices.size() > 1) {
                // If we have voice data, use the actual spread
                if (!instrument.voices.empty()) {
                    detuneSpread = instrument.voices.back().detune_cents - instrument.voices.front().detune_cents;
                }
            }

            for (int i = 0; i < instrument.voice_count; i++) {
                // Calculate detune value for this voice (linear distribution)
                double detune = 0.0;
                if (instrument.voice_count > 1) {
                    detune = -detuneSpread / 2.0 + (i * detuneSpread / (instrument.voice_count - 1));
                }

                source << "    voices.emplace_back(BASE_FREQ, " << std::fixed << std::setprecision(6) << detune << ");  // Voice " << i << "\n";
            }
        }
        source << "\n";
        source << "    // Render each sample\n";
        source << "    for (int sample_idx = 0; sample_idx < TOTAL_SAMPLES; sample_idx++) {\n";
        source << "        double time_sec = static_cast<double>(sample_idx) / SAMPLE_RATE;\n";
        source << "        float pan = CalculatePan(time_sec);\n";
        source << "        float gainL = static_cast<float>(1.0 - pan);\n";
        source << "        float gainR = static_cast<float>(pan);\n\n";
        source << "        float sampleL = 0.0f;\n";
        source << "        float sampleR = 0.0f;\n\n";
        source << "        // Process each voice\n";
        source << "        for (int v = 0; v < VOICE_COUNT; v++) {\n";
        source << "            float voice_sample = GenerateVoiceSample(voices[v]);\n";
        source << "            sampleL += voice_sample * gainL;\n";
        source << "            sampleR += voice_sample * gainR;\n";
        source << "        }\n\n";
        source << "        // Normalize by voice count to avoid clipping\n";
        source << "        sampleL /= VOICE_COUNT;\n";
        source << "        sampleR /= VOICE_COUNT;\n";
        source << "\n";
        source << "        left[sample_idx] = sampleL;\n";
        source << "        right[sample_idx] = sampleR;\n";
        source << "    }\n";
        source << "}\n\n";

        // WAV writer if requested
        if (options.include_wav_writer) {
            source << "// WAV file writer\n";
            source << "struct WavHeader {\n";
            source << "    char riff[4] = {'R', 'I', 'F', 'F'};\n";
            source << "    uint32_t chunk_size;\n";
            source << "    char wave[4] = {'W', 'A', 'V', 'E'};\n";
            source << "    char fmt[4] = {'f', 'm', 't', ' '};\n";
            source << "    uint32_t subchunk1_size = 16;\n";
            source << "    uint16_t audio_format = 1;  // PCM\n";
            source << "    uint16_t num_channels = 2;  // Stereo\n";
            source << "    uint32_t sample_rate;\n";
            source << "    uint32_t byte_rate;\n";
            source << "    uint16_t block_align;\n";
            source << "    uint16_t bits_per_sample = 16;\n";
            source << "    char data[4] = {'d', 'a', 't', 'a'};\n";
            source << "    uint32_t subchunk2_size;\n";
            source << "};\n\n";

            source << "// Write stereo audio to WAV file\n";
            source << "void WriteWav16(const std::string& filename,\n";
            source << "                 const std::vector<float>& left,\n";
            source << "                 const std::vector<float>& right,\n";
            source << "                 int sample_rate) {\n";
            source << "    \n";
            source << "    // Create WAV header\n";
            source << "    WavHeader header;\n";
            source << "    header.sample_rate = sample_rate;\n";
            source << "    header.byte_rate = sample_rate * 2 * 2;  // sample_rate * num_channels * bits_per_sample/8\n";
            source << "    header.block_align = 2 * 2;  // num_channels * bits_per_sample/8\n";
            source << "    header.subchunk2_size = static_cast<uint32_t>(left.size()) * 2 * 2;  // num_samples * num_channels * bits_per_sample/8\n";
            source << "    header.chunk_size = 36 + header.subchunk2_size;\n\n";
            source << "    std::ofstream file(filename, std::ios::binary);\n";
            source << "    if (!file.is_open()) {\n";
            source << "        std::cerr << \"Error: Could not open file for writing: \" << filename << std::endl;\n";
            source << "        return;\n";
            source << "    }\n\n";
            source << "    // Write header\n";
            source << "    file.write(reinterpret_cast<const char*>(&header), sizeof(WavHeader));\n\n";
            source << "    // Write interleaved stereo samples as 16-bit PCM\n";
            source << "    for (size_t i = 0; i < left.size(); i++) {\n";
            source << "        // Clamp and convert to 16-bit\n";
            source << "        int16_t l_sample = static_cast<int16_t>(std::max(-32768, std::min(32767, static_cast<int>(left[i] * 32767.0f))));\n";
            source << "        int16_t r_sample = static_cast<int16_t>(std::max(-32768, std::min(32767, static_cast<int>(right[i] * 32767.0f))));\n\n";
            source << "        file.write(reinterpret_cast<const char*>(&l_sample), sizeof(int16_t));\n";
            source << "        file.write(reinterpret_cast<const char*>(&r_sample), sizeof(int16_t));\n";
            source << "    }\n\n";
            source << "    file.close();\n";
            source << "    std::cout << \"Wrote audio to: \" << filename << std::endl;\n";
            source << "}\n\n";
        }

        // End namespace if provided
        if (!options.namespace_name.empty()) {
            source << "} // namespace " << options.namespace_name << "\n\n";
        }

        // Main function
        source << "// Main function\n";
        source << "int main() {\n";
        source << "    std::cout << \"Rendering instrument: " << instrument.instrument_id << "\" << std::endl;\n";
        source << "    std::cout << \"Sample rate: \" << SAMPLE_RATE << \" Hz\" << std::endl;\n";
        source << "    std::cout << \"Duration: \" << DURATION_SEC << \" seconds\" << std::endl;\n";
        source << "    std::cout << \"Voice count: \" << VOICE_COUNT << std::endl;\n\n";

        source << "    // Initialize output buffers\n";
        source << "    std::vector<float> left(TOTAL_SAMPLES, 0.0f);\n";
        source << "    std::vector<float> right(TOTAL_SAMPLES, 0.0f);\n\n";

        source << "    // Render the audio\n";
        source << "    Render(left, right);\n\n";

        if (options.include_wav_writer) {
            source << "    // Write WAV file\n";
            std::string wav_filename = options.output_wav_filename.empty() ? "output.wav" : options.output_wav_filename;
            source << "    WriteWav16(\"" << wav_filename << "\", left, right, SAMPLE_RATE);\n";
        } else {
            // Print first few samples for demo purposes
            source << "    // Print first 10 samples for verification\n";
            source << "    std::cout << \"First 10 samples (L, R):\" << std::endl;\n";
            source << "    for (int i = 0; i < std::min(10, TOTAL_SAMPLES); i++) {\n";
            source << "        std::cout << \"Sample \" << i << \": (\" << left[i] << \", \" << right[i] << \")\" << std::endl;\n";
            source << "    }\n";
        }

        source << "    std::cout << \"Rendering complete!\" << std::endl;\n";
        source << "    return 0;\n";
        source << "}\n";

        return MakeOk(source.str());
    }

}  // namespace ProtoVM