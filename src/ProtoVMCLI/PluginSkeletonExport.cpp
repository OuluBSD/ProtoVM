#include "PluginSkeletonExport.h"
#include <sstream>

static String GetVst3Skeleton(const PluginSkeletonOptions& opts) {
    std::ostringstream oss;
    
    if (opts.emit_comment_banner) {
        oss << "// VST3 Plugin Skeleton for ProtoVM Audio Engine\n";
        oss << "// Generated by ProtoVM Plugin Skeleton Export\n\n";
    }
    
    oss << "#include \"public.sdk/source/vst/vstsinglecomponenteffect.h\"\n";
    oss << "#include \"pluginterfaces/vst/ivstparameterchanges.h\"\n\n";
    
    oss << "// Include ProtoVM C ABI header\n";
    oss << "#include \"AudioEngineCAbi.h\"\n\n";
    
    oss << "class " << opts.plugin_name << " : public Steinberg::Vst::SingleComponentEffect {\n";
    oss << "public:\n";
    oss << "    " << opts.plugin_name << "() : engine(nullptr) {}\n";
    oss << "    ~" << opts.plugin_name << "() {\n";
    oss << "        if (engine) {\n";
    oss << "            ProtoVM_AudioEngine_Destroy(engine);\n";
    oss << "        }\n";
    oss << "    }\n\n";
    
    oss << "    tresult PLUGIN_API initialize(FUnknown* context) override {\n";
    oss << "        tresult result = SingleComponentEffect::initialize(context);\n";
    oss << "        if (result == kResultOk) {\n";
    oss << "            ProtoVM_AudioEngineConfig cfg = {};\n";
    oss << "            cfg.sample_rate = 48000;  // Will be updated in setBusArrangements\n";
    oss << "            cfg.max_block_size = 1024;\n";
    oss << "            cfg.num_channels = 2;\n";
    oss << "            cfg.voice_count = 1;\n";
    oss << "            \n";
    oss << "            engine = ProtoVM_AudioEngine_Create(&cfg);\n";
    oss << "        }\n";
    oss << "        return result;\n";
    oss << "    }\n\n";
    
    oss << "    tresult PLUGIN_API setBusArrangements(Steinberg::Vst::SpeakerArrangement* inputs, int32 numIns,\n";
    oss << "                                        Steinberg::Vst::SpeakerArrangement* outputs, int32 numOuts) override {\n";
    oss << "        // Set up stereo output bus\n";
    oss << "        return SingleComponentEffect::setBusArrangements(inputs, numIns, outputs, numOuts);\n";
    oss << "    }\n\n";
    
    oss << "    tresult PLUGIN_API setupProcessing(Steinberg::Vst::ProcessSetup& newSetup) override {\n";
    oss << "        if (engine) {\n";
    oss << "            ProtoVM_AudioEngineConfig cfg = {};\n";
    oss << "            cfg.sample_rate = static_cast<int>(newSetup.sampleRate);\n";
    oss << "            cfg.max_block_size = static_cast<int>(newSetup.maxSamplesPerBlock);\n";
    oss << "            cfg.num_channels = 2;\n";
    oss << "            cfg.voice_count = 1;\n";
    oss << "            \n";
    oss << "            // Re-create engine with new setup parameters\n";
    oss << "            ProtoVM_AudioEngine_Destroy(engine);\n";
    oss << "            engine = ProtoVM_AudioEngine_Create(&cfg);\n";
    oss << "        }\n";
    oss << "        return SingleComponentEffect::setupProcessing(newSetup);\n";
    oss << "    }\n\n";
    
    oss << "    tresult PLUGIN_API process(Steinberg::Vst::ProcessData& data) override {\n";
    oss << "        if (!engine || !data.outputs || !data.outputs[0].busBuffers) return kNotImplemented;\n";
    oss << "        \n";
    oss << "        if (data.numSamples > 0) {\n";
    oss << "            // Get audio output buffers\n";
    oss << "            float* outL = reinterpret_cast<float*>(data.outputs[0].busBuffers[0].data);\n";
    oss << "            float* outR = reinterpret_cast<float*>(data.outputs[0].busBuffers[1].data);\n";
    oss << "            \n";
    oss << "            // Process audio with ProtoVM engine\n";
    oss << "            ProtoVM_AudioEngine_Process(engine, nullptr, nullptr, outL, outR, data.numSamples);\n";
    oss << "        }\n";
    oss << "        return kResultOk;\n";
    oss << "    }\n\n";
    
    oss << "private:\n";
    oss << "    ProtoVM_AudioEngine* engine;\n";
    oss << "};\n\n";
    
    return String(oss.str().c_str());
}

static String GetLv2Skeleton(const PluginSkeletonOptions& opts) {
    std::ostringstream oss;
    
    if (opts.emit_comment_banner) {
        oss << "// LV2 Plugin Skeleton for ProtoVM Audio Engine\n";
        oss << "// Generated by ProtoVM Plugin Skeleton Export\n\n";
    }
    
    oss << "#include <lv2/lv2plug.in/ns/lv2core/lv2.h>\n";
    oss << "#include <lv2/lv2plug.in/ns/ext/atom/atom.h>\n\n";
    
    oss << "// Include ProtoVM C ABI header\n";
    oss << "#include \"AudioEngineCAbi.h\"\n\n";
    
    oss << "typedef struct {\n";
    oss << "    ProtoVM_AudioEngine* engine;\n";
    oss << "    float sample_rate;\n";
    oss << "    const float* control_in;\n";
    oss << "    float* audio_out_l;\n";
    oss << "    float* audio_out_r;\n";
    oss << "} " << opts.plugin_name << "_Handle;\n\n";
    
    oss << "static LV2_Handle instantiate(const LV2_Descriptor* descriptor,\n";
    oss << "                             double rate, const char* bundle_path,\n";
    oss << "                             const LV2_Feature* const* features) {\n";
    oss << "    " << opts.plugin_name << "_Handle* h = new " << opts.plugin_name << "_Handle();\n";
    oss << "    h->sample_rate = rate;\n";
    oss << "    \n";
    oss << "    ProtoVM_AudioEngineConfig cfg = {};\n";
    oss << "    cfg.sample_rate = static_cast<int>(rate);\n";
    oss << "    cfg.max_block_size = 1024;\n";
    oss << "    cfg.num_channels = 2;\n";
    oss << "    cfg.voice_count = 1;\n";
    oss << "    \n";
    oss << "    h->engine = ProtoVM_AudioEngine_Create(&cfg);\n";
    oss << "    return (LV2_Handle)h;\n";
    oss << "}\n\n";
    
    oss << "static void connect_port(LV2_Handle instance, uint32_t port, void* data) {\n";
    oss << "    " << opts.plugin_name << "_Handle* h = (" << opts.plugin_name << "_Handle*)instance;\n";
    oss << "    switch (port) {\n";
    oss << "        case 0: h->control_in = (const float*)data; break;\n";
    oss << "        case 1: h->audio_out_l = (float*)data; break;\n";
    oss << "        case 2: h->audio_out_r = (float*)data; break;\n";
    oss << "    }\n";
    oss << "}\n\n";
    
    oss << "static void activate(LV2_Handle instance) {\n";
    oss << "    " << opts.plugin_name << "_Handle* h = (" << opts.plugin_name << "_Handle*)instance;\n";
    oss << "    if (h->engine) {\n";
    oss << "        ProtoVM_AudioEngine_Reset(h->engine);\n";
    oss << "    }\n";
    oss << "}\n\n";
    
    oss << "static void run(LV2_Handle instance, uint32_t sample_count) {\n";
    oss << "    " << opts.plugin_name << "_Handle* h = (" << opts.plugin_name << "_Handle*)instance;\n";
    oss << "    \n";
    oss << "    if (h->engine && h->audio_out_l && h->audio_out_r) {\n";
    oss << "        // Process audio with ProtoVM engine\n";
    oss << "        ProtoVM_AudioEngine_Process(h->engine, nullptr, nullptr, \n";
    oss << "                                    h->audio_out_l, h->audio_out_r, sample_count);\n";
    oss << "    }\n";
    oss << "}\n\n";
    
    oss << "static void deactivate(LV2_Handle instance) {\n";
    oss << "    // Nothing special needed\n";
    oss << "}\n\n";
    
    oss << "static void cleanup(LV2_Handle instance) {\n";
    oss << "    " << opts.plugin_name << "_Handle* h = (" << opts.plugin_name << "_Handle*)instance;\n";
    oss << "    if (h->engine) {\n";
    oss << "        ProtoVM_AudioEngine_Destroy(h->engine);\n";
    oss << "    }\n";
    oss << "    delete h;\n";
    oss << "}\n\n";
    
    oss << "static const void* extension_data(const char* uri) {\n";
    oss << "    return NULL;\n";
    oss << "}\n\n";
    
    oss << "static const LV2_Descriptor descriptor = {\n";
    oss << "    \"" << opts.plugin_id << "\",\n";
    oss << "    instantiate,\n";
    oss << "    connect_port,\n";
    oss << "    activate,\n";
    oss << "    run,\n";
    oss << "    deactivate,\n";
    oss << "    cleanup,\n";
    oss << "    extension_data\n";
    oss << "};\n\n";
    
    oss << "LV2_SYMBOL_EXPORT const LV2_Descriptor* lv2_descriptor(uint32_t index) {\n";
    oss << "    if (index == 0) return &descriptor;\n";
    oss << "    else return NULL;\n";
    oss << "}\n\n";
    
    return String(oss.str().c_str());
}

static String GetClapSkeleton(const PluginSkeletonOptions& opts) {
    std::ostringstream oss;
    
    if (opts.emit_comment_banner) {
        oss << "// CLAP Plugin Skeleton for ProtoVM Audio Engine\n";
        oss << "// Generated by ProtoVM Plugin Skeleton Export\n\n";
    }
    
    oss << "#include <clap/clap.h>\n\n";
    
    oss << "// Include ProtoVM C ABI header\n";
    oss << "#include \"AudioEngineCAbi.h\"\n\n";
    
    oss << "typedef struct {\n";
    oss << "    clap_audio_setup setup;\n";
    oss << "    ProtoVM_AudioEngine* engine;\n";
    oss << "} " << opts.plugin_name << "_ cl_data;\n\n";
    
    oss << "static bool " << opts.plugin_name << "_init(const clap_host* host) {\n";
    oss << "    // Initialization code\n";
    oss << "    return true;\n";
    oss << "}\n\n";
    
    oss << "static void " << opts.plugin_name << "_destroy(const clap_plugin* plugin) {\n";
    oss << "    " << opts.plugin_name << "_cl_data* data = (" << opts.plugin_name << "_cl_data*)plugin->plugin_data;\n";
    oss << "    if (data->engine) {\n";
    oss << "        ProtoVM_AudioEngine_Destroy(data->engine);\n";
    oss << "    }\n";
    oss << "    delete data;\n";
    oss << "}\n\n";
    
    oss << "static bool " << opts.plugin_name << "_activate(const clap_plugin* plugin, double sample_rate, uint32_t min_frames_count, uint32_t max_frames_count) {\n";
    oss << "    " << opts.plugin_name << "_cl_data* data = (" << opts.plugin_name << "_cl_data*)plugin->plugin_data;\n";
    oss << "    \n";
    oss << "    ProtoVM_AudioEngineConfig cfg = {};\n";
    oss << "    cfg.sample_rate = static_cast<int>(sample_rate);\n";
    oss << "    cfg.max_block_size = static_cast<int>(max_frames_count);\n";
    oss << "    cfg.num_channels = 2;\n";
    oss << "    cfg.voice_count = 1;\n";
    oss << "    \n";
    oss << "    data->engine = ProtoVM_AudioEngine_Create(&cfg);\n";
    oss << "    return data->engine != nullptr;\n";
    oss << "}\n\n";
    
    oss << "static void " << opts.plugin_name << "_deactivate(const clap_plugin* plugin) {\n";
    oss << "    " << opts.plugin_name << "_cl_data* data = (" << opts.plugin_name << "_cl_data*)plugin->plugin_data;\n";
    oss << "    if (data->engine) {\n";
    oss << "        ProtoVM_AudioEngine_Destroy(data->engine);\n";
    oss << "        data->engine = nullptr;\n";
    oss << "    }\n";
    oss << "}\n\n";
    
    oss << "static bool " << opts.plugin_name << "_start_processing(const clap_plugin* plugin) {\n";
    oss << "    return true;\n";
    oss << "}\n\n";
    
    oss << "static void " << opts.plugin_name << "_stop_processing(const clap_plugin* plugin) {\n";
    oss << "    // Nothing needed\n";
    oss << "}\n\n";
    
    oss << "static void " << opts.plugin_name << "_process(const clap_plugin* plugin, const clap_process* process) {\n";
    oss << "    " << opts.plugin_name << "_cl_data* data = (" << opts.plugin_name << "_cl_data*)plugin->plugin_data;\n";
    oss << "    \n";
    oss << "    if (!data->engine || !process) return;\n";
    oss << "    \n";
    oss << "    uint32_t num_frames = process->frames_count;\n";
    oss << "    if (num_frames == 0) return;\n";
    oss << "    \n";
    oss << "    // Get audio output\n";
    oss << "    if (process->audio_outputs_count > 0 && process->audio_outputs) {\n";
    oss << "        const clap_audio_frame* in = nullptr;  // Input ignored for instrument\n";
    oss << "        clap_audio_frame* out = process->audio_outputs[0].data32;\n";
    oss << "        \n";
    oss << "        if (out && num_frames > 0) {\n";
    oss << "            // Extract left and right channels (assuming stereo)\n";
    oss << "            float* outL = &out[0][0];  // Channel 0\n";
    oss << "            float* outR = &out[1][0];  // Channel 1\n";
    oss << "            \n";
    oss << "            ProtoVM_AudioEngine_Process(data->engine, nullptr, nullptr, outL, outR, num_frames);\n";
    oss << "        }\n";
    oss << "    }\n";
    oss << "}\n\n";
    
    oss << "static const clap_plugin_t clap_plugin_ = {\n";
    oss << "    .init = " << opts.plugin_name << "_init,\n";
    oss << "    .destroy = " << opts.plugin_name << "_destroy,\n";
    oss << "    .activate = " << opts.plugin_name << "_activate,\n";
    oss << "    .deactivate = " << opts.plugin_name << "_deactivate,\n";
    oss << "    .start_processing = " << opts.plugin_name << "_start_processing,\n";
    oss << "    .stop_processing = " << opts.plugin_name << "_stop_processing,\n";
    oss << "    .reset = nullptr,  // Use default implementation\n";
    oss << "    .process = " << opts.plugin_name << "_process,\n";
    oss << "    // ... other callbacks would go here\n";
    oss << "};\n\n";
    
    return String(oss.str().c_str());
}

static String GetLadspaSkeleton(const PluginSkeletonOptions& opts) {
    std::ostringstream oss;
    
    if (opts.emit_comment_banner) {
        oss << "// LADSPA Plugin Skeleton for ProtoVM Audio Engine\n";
        oss << "// Generated by ProtoVM Plugin Skeleton Export\n\n";
    }
    
    oss << "#include <ladspa.h>\n\n";
    
    oss << "// Include ProtoVM C ABI header\n";
    oss << "#include \"AudioEngineCAbi.h\"\n\n";
    
    oss << "#define PLUGIN_ID 1234\n";
    oss << "#define PLUGIN_LABEL \"" << opts.plugin_id << "\"\n\n";
    
    oss << "typedef struct {\n";
    oss << "    LADSPA_Data* input;\n";
    oss << "    LADSPA_Data* output_l;\n";
    oss << "    LADSPA_Data* output_r;\n";
    oss << "    ProtoVM_AudioEngine* engine;\n";
    oss << "} " << opts.plugin_name << "_ladspa;\n\n";
    
    oss << "const LADSPA_Descriptor* ladspa_descriptor(unsigned long index) {\n";
    oss << "    static LADSPA_Descriptor descriptor;\n";
    oss << "    \n";
    oss << "    if (index != 0) return NULL;\n";
    oss << "    \n";
    oss << "    descriptor.UniqueID = PLUGIN_ID;\n";
    oss << "    descriptor.Label = PLUGIN_LABEL;\n";
    oss << "    descriptor.Properties = LADSPA_PROPERTY_HARD_RT_CAPABLE;\n";
    oss << "    descriptor.Name = \"" << opts.plugin_name << "\";\n";
    oss << "    descriptor.Maker = \"" << opts.vendor << "\";\n";
    oss << "    descriptor.Copyright = \"" << opts.vendor << " 2023\";\n";
    oss << "    descriptor.PortCount = 3;\n";
    oss << "    \n";
    oss << "    return &descriptor;\n";
    oss << "}\n\n";
    
    oss << "LADSPA_Handle " << opts.plugin_name << "_instantiate(const LADSPA_Descriptor* Descriptor, unsigned long sample_rate) {\n";
    oss << "    " << opts.plugin_name << "_ladspa* plugin = new " << opts.plugin_name << "_ladspa();\n";
    oss << "    \n";
    oss << "    ProtoVM_AudioEngineConfig cfg = {};\n";
    oss << "    cfg.sample_rate = sample_rate;\n";
    oss << "    cfg.max_block_size = 1024;\n";
    oss << "    cfg.num_channels = 2;\n";
    oss << "    cfg.voice_count = 1;\n";
    oss << "    \n";
    oss << "    plugin->engine = ProtoVM_AudioEngine_Create(&cfg);\n";
    oss << "    return (LADSPA_Handle)plugin;\n";
    oss << "}\n\n";
    
    oss << "void " << opts.plugin_name << "_connect_port(LADSPA_Handle Instance, unsigned long Port, LADSPA_Data* DataLocation) {\n";
    oss << "    " << opts.plugin_name << "_ladspa* plugin = (" << opts.plugin_name << "_ladspa*)Instance;\n";
    oss << "    \n";
    oss << "    switch (Port) {\n";
    oss << "        case 0: plugin->input = DataLocation; break;\n";
    oss << "        case 1: plugin->output_l = DataLocation; break;\n";
    oss << "        case 2: plugin->output_r = DataLocation; break;\n";
    oss << "    }\n";
    oss << "}\n\n";
    
    oss << "void " << opts.plugin_name << "_run(LADSPA_Handle Instance, unsigned long SampleCount) {\n";
    oss << "    " << opts.plugin_name << "_ladspa* plugin = (" << opts.plugin_name << "_ladspa*)Instance;\n";
    oss << "    \n";
    oss << "    if (plugin->engine && plugin->output_l && plugin->output_r) {\n";
    oss << "        ProtoVM_AudioEngine_Process(plugin->engine, plugin->input, plugin->input, \n";
    oss << "                                    plugin->output_l, plugin->output_r, SampleCount);\n";
    oss << "    }\n";
    oss << "}\n\n";
    
    oss << "void " << opts.plugin_name << "_cleanup(LADSPA_Handle Instance) {\n";
    oss << "    " << opts.plugin_name << "_ladspa* plugin = (" << opts.plugin_name << "_ladspa*)Instance;\n";
    oss << "    \n";
    oss << "    if (plugin->engine) {\n";
    oss << "        ProtoVM_AudioEngine_Destroy(plugin->engine);\n";
    oss << "    }\n";
    oss << "    delete plugin;\n";
    oss << "}\n\n";
    
    return String(oss.str().c_str());
}

Result<String> PluginSkeletonExport::EmitPluginSkeletonSource(
    const PluginSkeletonOptions& opts
) {
    switch (opts.target) {
        case PluginTargetKind::Vst3:
            return Result<String>::Success(GetVst3Skeleton(opts));
        case PluginTargetKind::Lv2:
            return Result<String>::Success(GetLv2Skeleton(opts));
        case PluginTargetKind::Clap:
            return Result<String>::Success(GetClapSkeleton(opts));
        case PluginTargetKind::Ladspa:
            return Result<String>::Success(GetLadspaSkeleton(opts));
        default:
            return Result<String>::Error("Unsupported plugin target kind");
    }
}